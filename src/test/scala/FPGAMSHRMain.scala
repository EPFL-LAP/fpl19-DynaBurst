// See LICENSE for license details.

package fpgamshr.main

import chisel3._
import chisel3.util.{log2Ceil}
import fpgamshr.packaging._

import org.scalatest.{Matchers, FlatSpec}

import fpgamshr.profiling.{Profiling}
import java.io.{File, BufferedWriter, FileWriter} // To generate the .tcl and .h files
import scala.sys.process._ // for the ! operator


/**
  * To just generate the Verilog for the FPGAMSHR, run:
  * {{{
  * test:runMain fpgamshr.main.FPGAMSHRVerilog
  * }}}
  */

object FPGAMSHRVerilog extends App {
  FPGAMSHR.outputDir = "."
  FPGAMSHR.loadParams(if(args.length > 0) Some(args(0)) else None)
    chisel3.Driver.execute(args, () => new FPGAMSHR)
}

/**
  * This provides a way to run the firrtl-interpreter REPL (or shell)
  * on the lowered firrtl generated by your circuit. You will be placed
  * in an interactive shell. This can be very helpful as a debugging
  * technique. Type help to see a list of commands.
  *
  * To run from sbt
  * {{{
  * test:runMain fpgamshr.main.FPGAMSHRRepl
  * }}}
  * To run from sbt and see the half a zillion options try
  * {{{
  * test:runMain fpgamshr.main.FPGAMSHRRepl --help
  * }}}
  */
object FPGAMSHRRepl extends App {
  iotesters.Driver.executeFirrtlRepl(args, () => new FPGAMSHR)
}

object FPGAMSHRIpBuilder extends App {
  FPGAMSHR.outputDir = "."
  FPGAMSHR.loadParams(if(args.length > 0) Some(args(0)) else None)
  val myModelBuilder = new FPGAMSHRModelBuilder()
  myModelBuilder.main(Array[String]())
}

class FPGAMSHRModelBuilder extends ModuleBuilder(".") {
  val modules: List[ModuleDef] = List(
    ModuleDef(null, // test module
      () => new FPGAMSHR(),
      CoreDefinition(
        name    = FPGAMSHR.ipName,
        vendor  = "LAP",
        library = "DynaBurst",
        version = FPGAMSHR.version.toString,
        CoreDefinition.root(FPGAMSHR.ipName)
      )
    )
  )
}

object FPGAMSHRVivadoBuilder extends App {
  class MyFileWriter(path: String) {
    val file = new File(path)
    val bw = new BufferedWriter(new FileWriter(file))
    def write(str: String) = bw.write(str)
    def close() = bw.close()
  }
  if (! new File("output").exists) {
    "mkdir output" !
  }
  if (! new File("output/vivado").exists) {
    "mkdir output/vivado" !
  }
  FPGAMSHR.loadParams(Some(args(0)))
  if (FPGAMSHR.systemType.isEmpty) {
    throw new IllegalArgumentException("Usage: system_type must be either 1 (PL) or 2 (PS)")
  }
  val currentDateTime = s"""${java.time.LocalDate.now.toString} ${java.time.LocalTime.now.format(java.time.format.DateTimeFormatter.ofPattern("kk:mm:ss")).toString}"""
  val tclFile = new MyFileWriter("output/vivado/params.tcl")
  tclFile.write(s"# Generated on ${currentDateTime} with Chisel code version ${FPGAMSHR.version}\n")
  tclFile.write(s"""set fpgamshr_name "${FPGAMSHR.ipName}"\n""")
  tclFile.write("set run_compilation 1\n")
  tclFile.close()
  if (! new File("output/sw").exists) {
    "mkdir output/sw" !
  }
  val headerFile = new MyFileWriter("output/sw/params.h")
  headerFile.write(s"// Generated on ${currentDateTime} with Chisel code version ${FPGAMSHR.version}\n")
  headerFile.write(s"#define ADDR_BITS ${FPGAMSHR.reqAddrWidth}\n")
  val memBaseAddr = if (FPGAMSHR.systemType.get == "PL") 0x80000000L else 0x100000L
  headerFile.write(s"#define MEM_BASE_ADDR 0x${new scala.runtime.RichLong(memBaseAddr).toHexString}\n")
  headerFile.write(s"#define ROB_DEPTH ${1 << FPGAMSHR.reqIdWidth}\n")
  headerFile.write(s"#define MSHR_HASH_TABLES ${FPGAMSHR.numHashTables}\n")
  headerFile.write(s"#define MSHR_PER_HASH_TABLE ${FPGAMSHR.numMSHRPerHashTable}\n")
  headerFile.write(s"#define SE_BUF_ENTRIES_PER_ROW ${FPGAMSHR.numSubentriesPerRow}\n")
  headerFile.write(s"#define SE_BUF_ROWS ${if(FPGAMSHR.numHashTables > 0) (1 << FPGAMSHR.subentriesAddrWidth) else 0}\n")
  headerFile.write(s"#define BURST_LENGTH_WIDTH ${FPGAMSHR.burstLengthWidth}\n")
  headerFile.write(s"#define CACHE_WAYS ${FPGAMSHR.numCacheWays}\n")
  headerFile.write(s"#define CACHE_SIZE ${FPGAMSHR.cacheSizeBytes}\n")
  headerFile.write(s"#define CACHE_SIZE_REDUCTION_WIDTH ${FPGAMSHR.cacheSizeReductionWidth}\n")
  headerFile.write(s"#define NUM_REQ_HANDLERS ${FPGAMSHR.numReqHandlers}\n")
  headerFile.write(s"#define REGS_PER_REQ_HANDLER ${1 << (Profiling.regAddrWidth + Profiling.subModuleAddrWidth)}\n")
  headerFile.write(s"#define REGS_PER_REQ_HANDLER_MODULE ${1 << Profiling.regAddrWidth}\n")
  headerFile.write(s"#define NUM_MEM_PORTS ${FPGAMSHR.numMemoryPorts}\n")
  headerFile.write(s"#define FPGAMSHR_EXISTS 1\n")
  headerFile.write(s"#define NUM_SPMV ${FPGAMSHR.numInputs}\n")
  headerFile.write(s"#define NUM_INPUTS ${FPGAMSHR.numInputs}\n")

  headerFile.close()
  val systemGeneratorPath = {FPGAMSHR.systemType.get match {
    case "PL" => "util/pl_generator.tcl" // 4 SpMV, 200 MHz
    case "PS" => "util/ps_generator.tcl" // 8 SpMV, 150 MHz
    case _ => throw new IllegalArgumentException("Last argument must be either PL or PS")
  }}
  s"cp ${systemGeneratorPath} output/vivado/generator.tcl" !
  // copy all files from sw to output/sw
  val f = (new File("sw")).listFiles.map(_.getName)
  for (file <- f) {s"cp sw/$file output/sw" !}
  val (linkerScriptToKeep, linkerScriptToRemove) = {FPGAMSHR.systemType.get match {
    case "PL" => ("lscript_plddr.ld", "lscript_psddr.ld")
    case "PS" => ("lscript_psddr.ld", "lscript_plddr.ld")
    case _ => ("","") // we already threw an exception if args(1) is neither PS nor PL
  }}

  s"rm output/sw/$linkerScriptToRemove" !

  s"mv output/sw/$linkerScriptToKeep output/sw/lscript.ld" !

  "ln -s ../../spmv spmv_tmp" !
  
  "mv spmv_tmp output/ip/spmv" !
}
